//
// This file is autogenerated
//

//
//  ProvisionUiRequest.swift
//  Keybase
//  Copyright Â© 2015 Keybase. All rights reserved.
//

import Foundation
import SwiftyJSON



//
// ProvisionUi
//

public class ProvisionUiRequest: Request {

/*!
 DEPRECATED:
 Called during device provisioning for the user to select a
 method for provisioning. gpgOption will be true if GPG
 should be offered as an option.
 */
  public func chooseProvisioningMethod(gpgOption: Bool) throws -> ProvisionMethod {
    let args: [String: AnyObject] = ["gpgOption": gpgOption]
    let response = try self.sendRequest("keybase.1.provisionUi.chooseProvisioningMethod", args: args)
    try checkNull(response)
    return ProvisionMethod(rawValue: JSON(response).intValue)!
  }

/*!
 Called during device provisioning for the user to select a 
 GPG method, either import the key into keybase's local keyring
 or use GPG to sign a provisioning statement.

 The keys are provided for display purposes, so the UI can 
 do something like "We found the following GPG keys on this 
 machine. How would you like to use one of them to provision
 this device?"

 After this, gpg_ui.selectKey will be called (if there are
 multiple keys available).
 */
  public func chooseGPGMethod(keys: [GPGKey]) throws -> GPGMethod {
    let args: [String: AnyObject] = ["keys": keys]
    let response = try self.sendRequest("keybase.1.provisionUi.chooseGPGMethod", args: args)
    try checkNull(response)
    return GPGMethod(rawValue: JSON(response).intValue)!
  }

/*!
 If there was an error importing a gpg key into the local
 keyring, tell the user and offer to switch to GPG signing
 with this key. Return true to switch to GPG signing, 
 false to abort provisioning.
 */
  public func switchToGPGSignOK(key: GPGKey, importError: String) throws -> Bool {
    let args: [String: AnyObject] = ["key": key, "importError": importError]
    let response = try self.sendRequest("keybase.1.provisionUi.switchToGPGSignOK", args: args)
    try checkNull(response)
    return JSON(response).boolValue
  }

  public func chooseDevice(devices: [Device]) throws -> String {
    let args: [String: AnyObject] = ["devices": devices]
    let response = try self.sendRequest("keybase.1.provisionUi.chooseDevice", args: args)
    try checkNull(response)
    return JSON(response).stringValue
  }

/*!
 If provisioning via device, this will be called so user can select the provisioner/provisionee device type: desktop or mobile.
 If selecting the existing device type, set kind to EXISTING_DEVICE_0.
 If selecting the new device type, set kind to NEW_DEVICE_1.
 */
  public func chooseDeviceType(kind: ChooseType) throws -> DeviceType {
    let args: [String: AnyObject] = ["kind": kind.rawValue]
    let response = try self.sendRequest("keybase.1.provisionUi.chooseDeviceType", args: args)
    try checkNull(response)
    return DeviceType(rawValue: JSON(response).intValue)!
  }

/*!
 DisplayAndPromptSecret displays a secret that the user can enter into the other device.
 It also can return a secret that the user enters into this device (from the other device).
 If it does not return a secret, it will be canceled when this device receives the secret via kex2.
 */
  public func displayAndPromptSecret(secret: NSData, phrase: String, otherDeviceType: DeviceType) throws -> SecretResponse {
    let args: [String: AnyObject] = ["secret": secret, "phrase": phrase, "otherDeviceType": otherDeviceType.rawValue]
    let response = try self.sendRequest("keybase.1.provisionUi.DisplayAndPromptSecret", args: args)
    try checkNull(response)
    return SecretResponse.fromJSON(JSON(response))
  }

/*!
 DisplaySecretExchanged is called when the kex2 secret has successfully been exchanged by the two
 devices.
 */
  public func displaySecretExchanged() throws {
    let args: [String: AnyObject] = [String: AnyObject]()
    try self.sendRequest("keybase.1.provisionUi.DisplaySecretExchanged", args: args)
  }

/*!
 PromptNewDeviceName is called when the device provisioning process needs a name for the new device.
 To help the clients not send a duplicate name, existingDevices is populated with the current device
 names for the user. If the device name returned to the service is invalid or already
 taken, it will call this again with an error message in errorMessage.
 */
  public func promptNewDeviceName(existingDevices: [String], errorMessage: String) throws -> String {
    let args: [String: AnyObject] = ["existingDevices": existingDevices, "errorMessage": errorMessage]
    let response = try self.sendRequest("keybase.1.provisionUi.PromptNewDeviceName", args: args)
    try checkNull(response)
    return JSON(response).stringValue
  }

/*!
 ProvisioneeSuccess is called on provisionee when it is successfully provisioned.
 */
  public func provisioneeSuccess(username: String, deviceName: String) throws {
    let args: [String: AnyObject] = ["username": username, "deviceName": deviceName]
    try self.sendRequest("keybase.1.provisionUi.ProvisioneeSuccess", args: args)
  }

/*!
 ProvisionerSuccess is called on provisioner when it successfully provisions another device.
 */
  public func provisionerSuccess(deviceName: String, deviceType: String) throws {
    let args: [String: AnyObject] = ["deviceName": deviceName, "deviceType": deviceType]
    try self.sendRequest("keybase.1.provisionUi.ProvisionerSuccess", args: args)
  }

}
