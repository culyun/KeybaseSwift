//
// This file is autogenerated
//

//
//  Identify.swift
//  Keybase
//  Copyright Â© 2015 Keybase. All rights reserved.
//

import Foundation
import SwiftyJSON



//
// Identify
//

public enum ProofState: Int {
	case None = 0
	case Ok = 1
	case TempFailure = 2
	case PermFailure = 3
	case Looking = 4
	case Superseded = 5
	case Posted = 6
	case Revoked = 7
}

public enum ProofStatus: Int {
	case None = 0
	case Ok = 1
	case Local = 2
	case Found = 3
	case BaseError = 100
	case HostUnreachable = 101
	case PermissionDenied = 103
	case FailedParse = 106
	case DnsError = 107
	case AuthFailed = 108
	case Http429 = 129
	case Http500 = 150
	case Timeout = 160
	case InternalError = 170
	case BaseHardError = 200
	case NotFound = 201
	case ContentFailure = 202
	case BadUsername = 203
	case BadRemoteId = 204
	case TextNotFound = 205
	case BadArgs = 206
	case ContentMissing = 207
	case TitleNotFound = 208
	case ServiceError = 209
	case TorSkipped = 210
	case TorIncompatible = 211
	case Http300 = 230
	case Http400 = 240
	case HttpOther = 260
	case EmptyJson = 270
	case Deleted = 301
	case ServiceDead = 302
	case BadSignature = 303
	case BadApiUrl = 304
	case UnknownType = 305
	case NoHint = 306
	case BadHintText = 307
}

public enum ProofType: Int {
	case None = 0
	case Keybase = 1
	case Twitter = 2
	case Github = 3
	case Reddit = 4
	case Coinbase = 5
	case Hackernews = 6
	case GenericWebSite = 1000
	case Dns = 1001
	case Pgp = 1002
	case Rooter = 100001
}

public typealias TrackToken = String
public enum TrackDiffType: Int {
	case None = 0
	case Error = 1
	case Clash = 2
	case Revoked = 3
	case Upgraded = 4
	case New = 5
	case RemoteFail = 6
	case RemoteWorking = 7
	case RemoteChanged = 8
	case NewEldest = 9
	case NoneViaTemporary = 10
}


public class TrackDiff {

	public let type: TrackDiffType
	public let displayMarkup: String

  public init(type: TrackDiffType, displayMarkup: String) {
    self.type = type
		self.displayMarkup = displayMarkup
  }

  public class func fromJSON(json: JSON) -> TrackDiff {
    return TrackDiff(type: TrackDiffType(rawValue: json["type"].intValue)!, displayMarkup: json["displayMarkup"].stringValue)
  }

  public class func fromJSONArray(json: [JSON]) -> [TrackDiff] {
    return json.map { fromJSON($0) }
  }
}


public class TrackSummary {

	public let username: String
	public let time: Int64
	public let isRemote: Bool

  public init(username: String, time: Int64, isRemote: Bool) {
    self.username = username
		self.time = time
		self.isRemote = isRemote
  }

  public class func fromJSON(json: JSON) -> TrackSummary {
    return TrackSummary(username: json["username"].stringValue, time: json["time"].int64Value, isRemote: json["isRemote"].boolValue)
  }

  public class func fromJSONArray(json: [JSON]) -> [TrackSummary] {
    return json.map { fromJSON($0) }
  }
}

public enum TrackStatus: Int {
	case NewOk = 1
	case NewZeroProofs = 2
	case NewFailProofs = 3
	case UpdateBrokenFailedProofs = 4
	case UpdateNewProofs = 5
	case UpdateOk = 6
	case UpdateBrokenRevoked = 7
}


public class TrackOptions {

	public let localOnly: Bool
	public let bypassConfirm: Bool
	public let forceRetrack: Bool
	public let expiringLocal: Bool

  public init(localOnly: Bool, bypassConfirm: Bool, forceRetrack: Bool, expiringLocal: Bool) {
    self.localOnly = localOnly
		self.bypassConfirm = bypassConfirm
		self.forceRetrack = forceRetrack
		self.expiringLocal = expiringLocal
  }

  public class func fromJSON(json: JSON) -> TrackOptions {
    return TrackOptions(localOnly: json["localOnly"].boolValue, bypassConfirm: json["bypassConfirm"].boolValue, forceRetrack: json["forceRetrack"].boolValue, expiringLocal: json["expiringLocal"].boolValue)
  }

  public class func fromJSONArray(json: [JSON]) -> [TrackOptions] {
    return json.map { fromJSON($0) }
  }
}

public enum IdentifyReasonType: Int {
	case None = 0
	case Id = 1
	case Track = 2
	case Encrypt = 3
	case Decrypt = 4
	case Verify = 5
	case Resource = 6
}


public class IdentifyReason {

	public let type: IdentifyReasonType
	public let reason: String
	public let resource: String

  public init(type: IdentifyReasonType, reason: String, resource: String) {
    self.type = type
		self.reason = reason
		self.resource = resource
  }

  public class func fromJSON(json: JSON) -> IdentifyReason {
    return IdentifyReason(type: IdentifyReasonType(rawValue: json["type"].intValue)!, reason: json["reason"].stringValue, resource: json["resource"].stringValue)
  }

  public class func fromJSONArray(json: [JSON]) -> [IdentifyReason] {
    return json.map { fromJSON($0) }
  }
}


public class IdentifyOutcome {

	public let username: String
	public let status: Status?
	public let warnings: [String]
	public let trackUsed: TrackSummary?
	public let trackStatus: TrackStatus
	public let numTrackFailures: Int
	public let numTrackChanges: Int
	public let numProofFailures: Int
	public let numRevoked: Int
	public let numProofSuccesses: Int
	public let revoked: [TrackDiff]
	public let trackOptions: TrackOptions
	public let forPGPPull: Bool
	public let reason: IdentifyReason

  public init(username: String, status: Status?, warnings: [String], trackUsed: TrackSummary?, trackStatus: TrackStatus, numTrackFailures: Int, numTrackChanges: Int, numProofFailures: Int, numRevoked: Int, numProofSuccesses: Int, revoked: [TrackDiff], trackOptions: TrackOptions, forPGPPull: Bool, reason: IdentifyReason) {
    self.username = username
		self.status = status
		self.warnings = warnings
		self.trackUsed = trackUsed
		self.trackStatus = trackStatus
		self.numTrackFailures = numTrackFailures
		self.numTrackChanges = numTrackChanges
		self.numProofFailures = numProofFailures
		self.numRevoked = numRevoked
		self.numProofSuccesses = numProofSuccesses
		self.revoked = revoked
		self.trackOptions = trackOptions
		self.forPGPPull = forPGPPull
		self.reason = reason
  }

  public class func fromJSON(json: JSON) -> IdentifyOutcome {
    return IdentifyOutcome(username: json["username"].stringValue, status: Status.fromJSON(json["status"]), warnings: String.fromJSONArray(json["warnings"].arrayValue), trackUsed: TrackSummary.fromJSON(json["trackUsed"]), trackStatus: TrackStatus(rawValue: json["trackStatus"].intValue)!, numTrackFailures: json["numTrackFailures"].intValue, numTrackChanges: json["numTrackChanges"].intValue, numProofFailures: json["numProofFailures"].intValue, numRevoked: json["numRevoked"].intValue, numProofSuccesses: json["numProofSuccesses"].intValue, revoked: TrackDiff.fromJSONArray(json["revoked"].arrayValue), trackOptions: TrackOptions.fromJSON(json["trackOptions"]), forPGPPull: json["forPGPPull"].boolValue, reason: IdentifyReason.fromJSON(json["reason"]))
  }

  public class func fromJSONArray(json: [JSON]) -> [IdentifyOutcome] {
    return json.map { fromJSON($0) }
  }
}


public class IdentifyRes {

	public let user: User?
	public let publicKeys: [PublicKey]
	public let outcome: IdentifyOutcome
	public let trackToken: String

  public init(user: User?, publicKeys: [PublicKey], outcome: IdentifyOutcome, trackToken: String) {
    self.user = user
		self.publicKeys = publicKeys
		self.outcome = outcome
		self.trackToken = trackToken
  }

  public class func fromJSON(json: JSON) -> IdentifyRes {
    return IdentifyRes(user: User.fromJSON(json["user"]), publicKeys: PublicKey.fromJSONArray(json["publicKeys"].arrayValue), outcome: IdentifyOutcome.fromJSON(json["outcome"]), trackToken: json["trackToken"].stringValue)
  }

  public class func fromJSONArray(json: [JSON]) -> [IdentifyRes] {
    return json.map { fromJSON($0) }
  }
}


public class RemoteProof {

	public let proofType: ProofType
	public let key: String
	public let value: String
	public let displayMarkup: String
	public let sigID: String
	public let mTime: Int64

  public init(proofType: ProofType, key: String, value: String, displayMarkup: String, sigID: String, mTime: Int64) {
    self.proofType = proofType
		self.key = key
		self.value = value
		self.displayMarkup = displayMarkup
		self.sigID = sigID
		self.mTime = mTime
  }

  public class func fromJSON(json: JSON) -> RemoteProof {
    return RemoteProof(proofType: ProofType(rawValue: json["proofType"].intValue)!, key: json["key"].stringValue, value: json["value"].stringValue, displayMarkup: json["displayMarkup"].stringValue, sigID: json["sigID"].stringValue, mTime: json["mTime"].int64Value)
  }

  public class func fromJSONArray(json: [JSON]) -> [RemoteProof] {
    return json.map { fromJSON($0) }
  }
}


public class Identify2Res {

	public let upk: UserPlusKeys

  public init(upk: UserPlusKeys) {
    self.upk = upk
  }

  public class func fromJSON(json: JSON) -> Identify2Res {
    return Identify2Res(upk: UserPlusKeys.fromJSON(json["upk"]))
  }

  public class func fromJSONArray(json: [JSON]) -> [Identify2Res] {
    return json.map { fromJSON($0) }
  }
}
