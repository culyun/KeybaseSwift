//
// This file is autogenerated
//

//
//  LoginRequest.swift
//  Keybase
//  Copyright Â© 2016 Keybase. All rights reserved.
//

import Foundation
import SwiftyJSON



//
// Login
//

public class LoginRequest: Request {

/*!
 Returns an array of information about accounts configured on the local
 machine. Currently configured accounts are defined as those that have stored
 secrets, but this definition may be expanded in the future.
 */
  public func getConfiguredAccounts() throws -> [ConfiguredAccount] {
    let args: [String: Any] = [String: Any]()
    let response = try self.sendRequest(method: "keybase.1.login.getConfiguredAccounts", args: args)
  try checkNull(response: response)
  return ConfiguredAccount.fromJSONArray(JSON(response).arrayValue)
  }

/*!
 Performs login. deviceType should be libkb.DeviceTypeDesktop
 or libkb.DeviceTypeMobile. usernameOrEmail is optional.
 If the current device isn't provisioned, this function will
 provision it.

 Note that if usernameOrEmail is an email address, only provisioning
 will be attempted. If the device is already provisioned, login
 via email address does not work.
 */
  public func login(deviceType: String, usernameOrEmail: String, clientType: ClientType) throws {
    let args: [String: Any] = ["deviceType": deviceType, "usernameOrEmail": usernameOrEmail, "clientType": clientType.rawValue]
    _ = try self.sendRequest(method: "keybase.1.login.login", args: args)
  }

/*!
 Removes any existing stored secret for the given username.
 loginWithStoredSecret(_, username) will fail after this is called.
 */
  public func clearStoredSecret(username: String) throws {
    let args: [String: Any] = ["username": username]
    _ = try self.sendRequest(method: "keybase.1.login.clearStoredSecret", args: args)
  }

  public func logout() throws {
    let args: [String: Any] = [String: Any]()
    _ = try self.sendRequest(method: "keybase.1.login.logout", args: args)
  }

  public func deprovision(username: String, doRevoke: Bool) throws {
    let args: [String: Any] = ["username": username, "doRevoke": doRevoke]
    _ = try self.sendRequest(method: "keybase.1.login.deprovision", args: args)
  }

  public func recoverAccountFromEmailAddress(email: String) throws {
    let args: [String: Any] = ["email": email]
    _ = try self.sendRequest(method: "keybase.1.login.recoverAccountFromEmailAddress", args: args)
  }

/*!
 PaperKey generates paper backup keys for restoring an account.
 It calls login_ui.displayPaperKeyPhrase with the phrase.
 */
  public func paperKey() throws {
    let args: [String: Any] = [String: Any]()
    _ = try self.sendRequest(method: "keybase.1.login.paperKey", args: args)
  }

/*!
 paperKeySubmit checks that paperPhrase is a valid paper key
 for the logged in user, caches the keys, and sends a notification.
 */
  public func paperKeySubmit(paperPhrase: String) throws {
    let args: [String: Any] = ["paperPhrase": paperPhrase]
    _ = try self.sendRequest(method: "keybase.1.login.paperKeySubmit", args: args)
  }

/*!
 Unlock restores access to local key store by priming passphrase stream cache.
 */
  public func unlock() throws {
    let args: [String: Any] = [String: Any]()
    _ = try self.sendRequest(method: "keybase.1.login.unlock", args: args)
  }

  public func unlockWithPassphrase(passphrase: String) throws {
    let args: [String: Any] = ["passphrase": passphrase]
    _ = try self.sendRequest(method: "keybase.1.login.unlockWithPassphrase", args: args)
  }

/*!
 pgpProvision is for devel/testing to provision a device via pgp using CLI
 with no user interaction.
 */
  public func pgpProvision(username: String, passphrase: String, deviceName: String) throws {
    let args: [String: Any] = ["username": username, "passphrase": passphrase, "deviceName": deviceName]
    _ = try self.sendRequest(method: "keybase.1.login.pgpProvision", args: args)
  }

/*!
 accountDelete is for devel/testing to delete the current user's account.
 */
  public func accountDelete() throws {
    let args: [String: Any] = [String: Any]()
    _ = try self.sendRequest(method: "keybase.1.login.accountDelete", args: args)
  }

}
