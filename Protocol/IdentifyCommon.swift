//
// This file is autogenerated
//

//
//  IdentifyCommon.swift
//  Keybase
//  Copyright Â© 2016 Keybase. All rights reserved.
//

import Foundation
import SwiftyJSON



//
// IdentifyCommon
//

public typealias TrackToken = String
public enum TrackDiffType: Int {
	case none = 0
	case error = 1
	case clash = 2
	case revoked = 3
	case upgraded = 4
	case new = 5
	case remoteFail = 6
	case remoteWorking = 7
	case remoteChanged = 8
	case newEldest = 9
	case noneViaTemporary = 10
}


public class TrackDiff {

	public let type: TrackDiffType?
	public let displayMarkup: String?

  public init(type: TrackDiffType, displayMarkup: String) {
    self.type = type
		self.displayMarkup = displayMarkup
  }

  public class func fromJSON(_ json: JSON) -> TrackDiff {
    return TrackDiff(type: TrackDiffType(rawValue: json["type"].intValue)!, displayMarkup: json["displayMarkup"].stringValue)
  }

  public class func fromJSONArray(_ json: [JSON]) -> [TrackDiff] {
    return json.map { fromJSON($0) }
  }

}



public class TrackSummary {

	public let username: String?
	public let time: Int64?
	public let isRemote: Bool?

  public init(username: String, time: Int64, isRemote: Bool) {
    self.username = username
		self.time = time
		self.isRemote = isRemote
  }

  public class func fromJSON(_ json: JSON) -> TrackSummary {
    return TrackSummary(username: json["username"].stringValue, time: json["time"].int64Value, isRemote: json["isRemote"].boolValue)
  }

  public class func fromJSONArray(_ json: [JSON]) -> [TrackSummary] {
    return json.map { fromJSON($0) }
  }

}


public enum TrackStatus: Int {
	case newOk = 1
	case newZeroProofs = 2
	case newFailProofs = 3
	case updateBrokenFailedProofs = 4
	case updateNewProofs = 5
	case updateOk = 6
	case updateBrokenRevoked = 7
}


public class TrackOptions {

	public let localOnly: Bool?
	public let bypassConfirm: Bool?
	public let forceRetrack: Bool?
	public let expiringLocal: Bool?
	public let forPGPPull: Bool?

  public init(localOnly: Bool, bypassConfirm: Bool, forceRetrack: Bool, expiringLocal: Bool, forPGPPull: Bool) {
    self.localOnly = localOnly
		self.bypassConfirm = bypassConfirm
		self.forceRetrack = forceRetrack
		self.expiringLocal = expiringLocal
		self.forPGPPull = forPGPPull
  }

  public class func fromJSON(_ json: JSON) -> TrackOptions {
    return TrackOptions(localOnly: json["localOnly"].boolValue, bypassConfirm: json["bypassConfirm"].boolValue, forceRetrack: json["forceRetrack"].boolValue, expiringLocal: json["expiringLocal"].boolValue, forPGPPull: json["forPGPPull"].boolValue)
  }

  public class func fromJSONArray(_ json: [JSON]) -> [TrackOptions] {
    return json.map { fromJSON($0) }
  }

}


public enum IdentifyReasonType: Int {
	case none = 0
	case id = 1
	case track = 2
	case encrypt = 3
	case decrypt = 4
	case verify = 5
	case resource = 6
	case background = 7
}


public class IdentifyReason {

	public let type: IdentifyReasonType?
	public let reason: String?
	public let resource: String?

  public init(type: IdentifyReasonType, reason: String, resource: String) {
    self.type = type
		self.reason = reason
		self.resource = resource
  }

  public class func fromJSON(_ json: JSON) -> IdentifyReason {
    return IdentifyReason(type: IdentifyReasonType(rawValue: json["type"].intValue)!, reason: json["reason"].stringValue, resource: json["resource"].stringValue)
  }

  public class func fromJSONArray(_ json: [JSON]) -> [IdentifyReason] {
    return json.map { fromJSON($0) }
  }

}



public class IdentifyOutcome {

	public let username: String?
	public let status: Status??
	public let warnings: [String]?
	public let trackUsed: TrackSummary??
	public let trackStatus: TrackStatus?
	public let numTrackFailures: Int?
	public let numTrackChanges: Int?
	public let numProofFailures: Int?
	public let numRevoked: Int?
	public let numProofSuccesses: Int?
	public let revoked: [TrackDiff]?
	public let trackOptions: TrackOptions?
	public let forPGPPull: Bool?
	public let reason: IdentifyReason?

  public init(username: String, status: Status?, warnings: [String], trackUsed: TrackSummary?, trackStatus: TrackStatus, numTrackFailures: Int, numTrackChanges: Int, numProofFailures: Int, numRevoked: Int, numProofSuccesses: Int, revoked: [TrackDiff], trackOptions: TrackOptions, forPGPPull: Bool, reason: IdentifyReason) {
    self.username = username
		self.status = status
		self.warnings = warnings
		self.trackUsed = trackUsed
		self.trackStatus = trackStatus
		self.numTrackFailures = numTrackFailures
		self.numTrackChanges = numTrackChanges
		self.numProofFailures = numProofFailures
		self.numRevoked = numRevoked
		self.numProofSuccesses = numProofSuccesses
		self.revoked = revoked
		self.trackOptions = trackOptions
		self.forPGPPull = forPGPPull
		self.reason = reason
  }

  public class func fromJSON(_ json: JSON) -> IdentifyOutcome {
    return IdentifyOutcome(username: json["username"].stringValue, status: Status.fromJSON(json["status"]), warnings: String.fromJSONArray(json["warnings"].arrayValue), trackUsed: TrackSummary.fromJSON(json["trackUsed"]), trackStatus: TrackStatus(rawValue: json["trackStatus"].intValue)!, numTrackFailures: json["numTrackFailures"].intValue, numTrackChanges: json["numTrackChanges"].intValue, numProofFailures: json["numProofFailures"].intValue, numRevoked: json["numRevoked"].intValue, numProofSuccesses: json["numProofSuccesses"].intValue, revoked: TrackDiff.fromJSONArray(json["revoked"].arrayValue), trackOptions: TrackOptions.fromJSON(json["trackOptions"]), forPGPPull: json["forPGPPull"].boolValue, reason: IdentifyReason.fromJSON(json["reason"]))
  }

  public class func fromJSONArray(_ json: [JSON]) -> [IdentifyOutcome] {
    return json.map { fromJSON($0) }
  }

}



public class IdentifyRes {

	public let user: User??
	public let publicKeys: [PublicKey]?
	public let outcome: IdentifyOutcome?
	public let trackToken: String?

  public init(user: User?, publicKeys: [PublicKey], outcome: IdentifyOutcome, trackToken: String) {
    self.user = user
		self.publicKeys = publicKeys
		self.outcome = outcome
		self.trackToken = trackToken
  }

  public class func fromJSON(_ json: JSON) -> IdentifyRes {
    return IdentifyRes(user: User.fromJSON(json["user"]), publicKeys: PublicKey.fromJSONArray(json["publicKeys"].arrayValue), outcome: IdentifyOutcome.fromJSON(json["outcome"]), trackToken: json["trackToken"].stringValue)
  }

  public class func fromJSONArray(_ json: [JSON]) -> [IdentifyRes] {
    return json.map { fromJSON($0) }
  }

}



public class RemoteProof {

	public let proofType: ProofType?
	public let key: String?
	public let value: String?
	public let displayMarkup: String?
	public let sigID: String?
	public let mTime: Int64?

  public init(proofType: ProofType, key: String, value: String, displayMarkup: String, sigID: String, mTime: Int64) {
    self.proofType = proofType
		self.key = key
		self.value = value
		self.displayMarkup = displayMarkup
		self.sigID = sigID
		self.mTime = mTime
  }

  public class func fromJSON(_ json: JSON) -> RemoteProof {
    return RemoteProof(proofType: ProofType(rawValue: json["proofType"].intValue)!, key: json["key"].stringValue, value: json["value"].stringValue, displayMarkup: json["displayMarkup"].stringValue, sigID: json["sigID"].stringValue, mTime: json["mTime"].int64Value)
  }

  public class func fromJSONArray(_ json: [JSON]) -> [RemoteProof] {
    return json.map { fromJSON($0) }
  }

}

